#include "RenderGraphVulkanRuntime.hpp"

#include "Gpu.hpp"
#include "FramebufferBuilder.hpp"
#include "RenderGraphDefinition.hpp"

namespace lft::rg {

struct RenderGraphBuilderResource {
	uint32_t remaining;
	RenderGraphResource resource;	
};

struct RenderGraphBuilderContext {
	std::map<std::string, RenderGraphBuilderResource> resources;
};

RenderGraphRenderPassNode create_render_pass(
		std::shared_ptr<const Gpu> gpu,
		const RenderGraphDefinition& render_graph,
		const RenderPass& render_pass,
		RenderGraphBuilderContext& context
) {
	std::vector<VkAttachmentDescription2> attachments(render_pass.outputs().size());
	std::vector<VkAttachmentReference2> references(render_pass.outputs().size());
	std::optional<VkAttachmentReference2> depth_attachment = {};

	/* create attachment for each defined output */
	for(auto& output : render_pass.outputs()) {
		VkImageLayout initial_layout = VK_IMAGE_LAYOUT_UNDEFINED;
		VkImageLayout final_layout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
		VkAttachmentLoadOp load_op = VK_ATTACHMENT_LOAD_OP_CLEAR;
		VkAttachmentStoreOp store_op = VK_ATTACHMENT_STORE_OP_DONT_CARE;

		if(context.resources.contains(output.name())) {
			auto& resource = context.resources.at(output.name());
			resource.remaining--;
		}

		VkAttachmentDescription2 description = {
			.sType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2,
			.format = output.format(),
			.samples = VK_SAMPLE_COUNT_1_BIT,
			.loadOp = load_op,
			.storeOp = store_op,
			.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
			.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
			.initialLayout = initial_layout,
			.finalLayout = final_layout
		};
	}

	/* create single subpass */
	VkSubpassDescription2 subpass = {
		.sType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2,
		.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS,
		.colorAttachmentCount = (uint32_t)references.size(),
		.pColorAttachments = references.data(),
		.pDepthStencilAttachment = depth_attachment.has_value() ?
			&depth_attachment.value() : nullptr
	};

	std::optional<VkSubpassDependency2> dependency = {};

	VkRenderPassCreateInfo2 render_pass_info = {
		.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2,
		
		.attachmentCount = (uint32_t)attachments.size(),
		.pAttachments = attachments.data(),

		.subpassCount = 1,
		.pSubpasses = &subpass,

		.dependencyCount = dependency.has_value(),
		.pDependencies = dependency.has_value() ? &dependency.value() : nullptr
	};

	VkRenderPass renderpass = VK_NULL_HANDLE;
	if(vkCreateRenderPass2(m_gpu->dev(), &render_pass_info, nullptr, &renderpass)) {
		throw std::runtime_error("Failed to create render pass for " + render_pass.name());
	}

	FramebufferBuilder(renderpass, VkExtent2D {}, {});

	return RenderGraphRenderPassNode(renderpass);
}

std::vector<VkSemaphore> create_semaphores(std::shared_ptr<const Gpu> gpu, uint32_t count) {
	std::vector<VkSemaphore> semaphores(count);
	VkSemaphoreCreateInfo semaphore_info = {
		.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
		.flags = 0
	};

	for(uint32_t i = 0; i < count; i++) {
		vkCreateSemaphore(
			gpu->dev(),
			&semaphore_info,
			nullptr,
			&semaphores[i]
		);
	}

	return semaphores;
}

std::vector<RenderGraphResource> collect_resources(const RenderGraphDefinition& render_graph) {
	std::vector<RenderGraphResource> resources;
	for(auto& render_pass : render_graph.render_passes()) {
		for(auto& output : render_pass.outputs()) {
			resources.push_back(output);
		}
	}

	return resources;
}

RenderGraphBuffer create_buffer(
		std::shared_ptr<Gpu> gpu,
		const RenderGraphDefinition& render_graph_definition
) {
	auto semaphores = create_semaphores(gpu, render_graph_definition.dependencies().size());
	auto resources = collect_resources(render_graph_definition);

	for(auto& cmd_buf_node : render_graph_definition.command_buffers()) {
		VkCommandBufferAllocateInfo alloc_info = {
			.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
			.commandPool = gpu->graphics_command_pool(),
			.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
			.commandBufferCount = 1
		};

		VkCommandBuffer cmd_buf;
		vkAllocateCommandBuffers(
			gpu->dev(),
			&alloc_info,
			&cmd_buf
		);


		std::vector<RenderGraphRenderPassNode> render_passes;

		for(auto& render_pass_name : cmd_buf_node.render_passes) {
			auto& render_pass = render_graph_definition.render_pass(render_pass_name);
			render_passes.push_back(create_render_pass(render_graph_definition, render_pass));
		}

		RenderGraphCommandBufferNode render_graph_cmd_buf = {
			.cmd_buf = cmd_buf,
			.render_passes = render_passes,
			.dependencies = cmd_buf_node.dependencies,
			.signal = cmd_buf_node.signal
		};
	}

	RenderGraphBuffer buffer = {
		.command_buffers = {},
		.output_command_buffers = {},
		.resources = {},
		.semaphores = {},
		.frame_finished_fence = {},
	};
}

RenderGraphVulkanRuntime::RenderGraphVulkanRuntime(
		std::shared_ptr<Gpu> gpu,
		std::shared_ptr<ImageChain> output_chain,
		uint32_t num_buffers,
		RenderGraphDefinition& render_graph_definition
) : m_gpu(gpu),
	m_output_chain(output_chain) {

	for(uint32_t i = 0; i < num_buffers; i++) {
		m_buffers.push_back(create_buffer(gpu, render_graph_definition));
	}
}

void RenderGraphVulkanRuntime::submit_command_buffer(
		const RenderGraphBuffer& buffer,
		const RenderGraphCommandBufferNode& cmdbuf,
		VkFence signal_fence // TODO: Something more intuitive -> it is to detect the previous run is finished
) {
	VkCommandBufferSubmitInfoKHR cmdbuf_submit_info = {
		.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR,
		.commandBuffer = cmdbuf.cmd_buf,
		.deviceMask = 0,
	};

	VkSemaphoreSubmitInfo signal_info = {
		.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO,
		.semaphore = cmdbuf.signal,
		.value = 1,
		.stageMask = VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR,
		.deviceIndex = 0
	};

	VkSubmitInfo2 submit_info = {
		.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO_2,
		.waitSemaphoreInfoCount = (uint32_t)cmdbuf.num_dependencies(),
		.pWaitSemaphoreInfos = cmdbuf.wait_for().data(),
		.commandBufferInfoCount = 1,
		.pCommandBufferInfos = &cmdbuf_submit_info,
		.signalSemaphoreInfoCount = 1,
		.pSignalSemaphoreInfos = &signal_info
	};

	m_gpu->enqueue_graphics(&submit_info, signal_fence);
}

void RenderGraphVulkanRuntime::run(uint32_t chain_image_idx) {
	auto& buffer = get_next_buffer();

	wait_for_previous_run(buffer);

	for(auto& command_buffer : buffer.command_buffers) {
		record_command_buffer(command_buffer);
		submit_command_buffer(command_buffer);
	}
}

}
